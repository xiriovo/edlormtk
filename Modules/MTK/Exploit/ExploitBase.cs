using System;
using System.IO;
using System.Threading.Tasks;
using tools.Modules.MTK.Protocol;
using tools.Modules.MTK.Models;

namespace tools.Modules.MTK.Exploit
{
    /// <summary>
    /// 漏洞利用类型
    /// </summary>
    public enum ExploitType
    {
        None,
        Kamakiri,       // USB 控制传输漏洞
        Kamakiri2,      // Kamakiri 变种 (通过 brom_register_access)
        Amonet,         // GCPU 加密引擎漏洞
        Hashimoto,      // CQDMA DMA 控制器漏洞
    }

    /// <summary>
    /// 漏洞利用基类
    /// </summary>
    public abstract class ExploitBase : IDisposable
    {
        protected readonly PreloaderProtocol Preloader;
        protected readonly ChipConfig ChipConfig;

        public event Action<string>? OnLog;

        protected ExploitBase(PreloaderProtocol preloader, ChipConfig chipConfig)
        {
            Preloader = preloader;
            ChipConfig = chipConfig;
        }

        /// <summary>
        /// 执行漏洞利用
        /// </summary>
        public abstract bool Exploit(byte[] payload, uint payloadAddr);

        /// <summary>
        /// 运行 Payload
        /// </summary>
        public abstract Task<bool> RunPayloadAsync(byte[] payload, uint? addr = null);

        /// <summary>
        /// Dump BROM
        /// </summary>
        public abstract Task<byte[]?> DumpBromAsync(uint length = 0x20000);

        /// <summary>
        /// Dump Preloader
        /// </summary>
        public abstract Task<byte[]?> DumpPreloaderAsync();

        /// <summary>
        /// 禁用内存黑名单保护
        /// </summary>
        public abstract bool DisableRangeBlacklist();

        /// <summary>
        /// 崩溃设备进入 BROM
        /// </summary>
        public virtual bool CrashDevice(int mode = 0)
        {
            Log("Crashing device to enter BROM mode...");
            try
            {
                switch (mode)
                {
                    case 0:
                        // 发送无效 DA
                        Preloader.SendDA(0, 0x100, 0x100, new byte[0x100]);
                        break;
                    case 1:
                        // 读取无效地址
                        Preloader.Read32(0, 0x100);
                        break;
                    case 2:
                        // 写入无效地址
                        Preloader.Write32(0, 0);
                        break;
                }
                return true;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// 修复 Payload (替换硬编码地址)
        /// </summary>
        protected byte[] FixPayload(byte[] payload, bool addSignature = true)
        {
            byte[] fixed_payload = new byte[payload.Length + (addSignature ? 0x100 : 0)];
            Array.Copy(payload, fixed_payload, payload.Length);

            // 检查并替换 Watchdog 地址 (默认 0x10007000)
            int wdOffset = payload.Length - 4;
            if (wdOffset >= 0 && BitConverter.ToUInt32(payload, wdOffset) == 0x10007000)
            {
                BitConverter.GetBytes(ChipConfig.Watchdog).CopyTo(fixed_payload, wdOffset);
            }

            // 检查并替换 UART 地址 (默认 0x11002000)  
            int uartOffset = payload.Length - 8;
            if (uartOffset >= 0 && BitConverter.ToUInt32(payload, uartOffset) == 0x11002000)
            {
                BitConverter.GetBytes(ChipConfig.Uart).CopyTo(fixed_payload, uartOffset);
            }

            // 4 字节对齐
            int alignedLen = (fixed_payload.Length + 3) & ~3;
            if (alignedLen != fixed_payload.Length)
            {
                byte[] aligned = new byte[alignedLen];
                Array.Copy(fixed_payload, aligned, fixed_payload.Length);
                return aligned;
            }

            return fixed_payload;
        }

        /// <summary>
        /// 加载 Payload 文件
        /// </summary>
        protected byte[]? LoadPayload(string filename)
        {
            if (!File.Exists(filename))
            {
                Log($"Payload file not found: {filename}");
                return null;
            }

            return File.ReadAllBytes(filename);
        }

        /// <summary>
        /// 反转双字节序
        /// </summary>
        protected static uint ReverseBytes(uint value)
        {
            return ((value & 0x000000FF) << 24) |
                   ((value & 0x0000FF00) << 8) |
                   ((value & 0x00FF0000) >> 8) |
                   ((value & 0xFF000000) >> 24);
        }

        protected void Log(string message)
        {
            OnLog?.Invoke($"[Exploit] {message}");
            System.Diagnostics.Debug.WriteLine($"[Exploit] {message}");
        }

        public virtual void Dispose() { }
    }
}
