// ============================================================================
// MultiFlash TOOL - MediaTek Exploit Manager
// 联发科漏洞利用管理器 | MTKエクスプロイトマネージャ | MTK 익스플로잇 관리자
// ============================================================================
// [EN] Automatic exploit selection and execution for MTK bootrom bypass
//      Supports Kamakiri, Kamakiri2, Amonet, Hashimoto exploits
// [中文] MTK Bootrom 绕过的自动漏洞利用选择和执行
//       支持 Kamakiri、Kamakiri2、Amonet、Hashimoto 漏洞
// [日本語] MTK Bootromバイパス用の自動エクスプロイト選択と実行
//         Kamakiri、Kamakiri2、Amonet、Hashimotoエクスプロイトをサポート
// [한국어] MTK Bootrom 우회를 위한 자동 익스플로잇 선택 및 실행
//         Kamakiri, Kamakiri2, Amonet, Hashimoto 익스플로잇 지원
// [Español] Selección y ejecución automática de exploits para bypass de MTK bootrom
//           Soporta exploits Kamakiri, Kamakiri2, Amonet, Hashimoto
// [Русский] Автоматический выбор и выполнение эксплойтов для обхода MTK bootrom
//           Поддержка эксплойтов Kamakiri, Kamakiri2, Amonet, Hashimoto
// ============================================================================
// GitHub: https://github.com/xiriovo/edlormtk
// Contact: QQ 1708298587 | Email: 1708298587@qq.com
// License: MIT
// ============================================================================

using System;
using System.IO;
using System.Threading.Tasks;
using LibUsbDotNet;
using tools.Modules.MTK.Protocol;
using tools.Modules.MTK.Models;

namespace tools.Modules.MTK.Exploit
{
    /// <summary>
    /// Exploit Manager - Auto select and execute MTK bootrom exploits
    /// 漏洞利用管理器 - 自动选择并执行适合的 MTK bootrom 漏洞利用方法
    /// エクスプロイトマネージャ - MTK bootromエクスプロイトの自動選択と実行
    /// 익스플로잇 관리자 - MTK bootrom 익스플로잇 자동 선택 및 실행
    /// </summary>
    public class ExploitManager
    {
        private readonly PreloaderProtocol _preloader;
        private readonly ChipConfig _chipConfig;
        private readonly TargetConfig _targetConfig;
        private UsbDevice? _usbDevice;

        private ExploitBase? _currentExploit;

        public event Action<string>? OnLog;

        public ExploitManager(PreloaderProtocol preloader, ChipConfig chipConfig, TargetConfig targetConfig)
        {
            _preloader = preloader;
            _chipConfig = chipConfig;
            _targetConfig = targetConfig;
        }

        /// <summary>
        /// 设置 USB 设备 (用于 Kamakiri/Kamakiri2)
        /// </summary>
        public void SetUsbDevice(UsbDevice device)
        {
            _usbDevice = device;
        }

        /// <summary>
        /// 判断设备是否启用了安全启动
        /// </summary>
        public bool HasSecurity => _targetConfig.SlaEnabled || _targetConfig.DaaEnabled || _targetConfig.SbcEnabled;

        /// <summary>
        /// 获取推荐的漏洞利用类型
        /// </summary>
        public ExploitType GetRecommendedExploit()
        {
            // 检查芯片支持的漏洞利用方法
            // 优先级: Kamakiri2 > Kamakiri > CQDMA (Hashimoto) > GCPU (Amonet)

            // Kamakiri2: 需要 brom_register_access 和 send_ptr
            if (_chipConfig.BromRegisterAccess != null && _chipConfig.BromRegisterAccess.Count > 0 &&
                _chipConfig.SendPtr != null && _chipConfig.SendPtr.Count > 0)
            {
                return ExploitType.Kamakiri2;
            }

            // Kamakiri: 需要 var1
            if (_chipConfig.Var1 != 0)
            {
                return ExploitType.Kamakiri;
            }

            // CQDMA (Hashimoto): 需要 cqdma_base 和 ap_dma_mem
            if (_chipConfig.CqdmaBase != 0 && _chipConfig.ApDmaMem != 0)
            {
                return ExploitType.Hashimoto;
            }

            // GCPU (Amonet): 需要 gcpu_base
            if (_chipConfig.GcpuBase != 0)
            {
                return ExploitType.Amonet;
            }

            return ExploitType.None;
        }

        /// <summary>
        /// 创建漏洞利用实例
        /// </summary>
        public ExploitBase? CreateExploit(ExploitType type)
        {
            _currentExploit?.Dispose();

            try
            {
                _currentExploit = type switch
                {
                    ExploitType.Kamakiri => new Kamakiri(_preloader, _chipConfig, _usbDevice),
                    ExploitType.Kamakiri2 => new Kamakiri2(_preloader, _chipConfig, _usbDevice),
                    ExploitType.Amonet => new Amonet(_preloader, _chipConfig),
                    ExploitType.Hashimoto => new Hashimoto(_preloader, _chipConfig),
                    _ => null
                };

                if (_currentExploit != null)
                {
                    _currentExploit.OnLog += msg => OnLog?.Invoke(msg);
                }

                return _currentExploit;
            }
            catch (Exception ex)
            {
                Log($"Failed to create exploit {type}: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// 自动选择并执行漏洞利用
        /// </summary>
        public async Task<bool> RunPayloadAsync(byte[] payload, uint? address = null)
        {
            var exploitType = GetRecommendedExploit();
            if (exploitType == ExploitType.None)
            {
                Log("No suitable exploit found for this chip");
                return false;
            }

            Log($"Selected exploit: {exploitType}");

            var exploit = CreateExploit(exploitType);
            if (exploit == null)
            {
                Log("Failed to create exploit instance");
                return false;
            }

            return await exploit.RunPayloadAsync(payload, address);
        }

        /// <summary>
        /// 使用指定的漏洞利用发送 Payload
        /// </summary>
        public async Task<bool> SendPayloadAsync(byte[] payload, uint payloadAddr, ExploitType type)
        {
            var exploit = CreateExploit(type);
            if (exploit == null)
            {
                Log($"Failed to create {type} exploit");
                return false;
            }

            return await exploit.RunPayloadAsync(payload, payloadAddr);
        }

        /// <summary>
        /// Dump BROM
        /// </summary>
        public async Task<byte[]?> DumpBromAsync(uint length = 0x20000)
        {
            var exploitType = GetRecommendedExploit();
            if (exploitType == ExploitType.None)
            {
                Log("No suitable exploit found for BROM dump");
                return null;
            }

            var exploit = CreateExploit(exploitType);
            if (exploit == null)
            {
                Log("Failed to create exploit instance");
                return null;
            }

            return await exploit.DumpBromAsync(length);
        }

        /// <summary>
        /// Dump Preloader
        /// </summary>
        public async Task<byte[]?> DumpPreloaderAsync()
        {
            var exploitType = GetRecommendedExploit();
            if (exploitType == ExploitType.None)
            {
                Log("No suitable exploit found for Preloader dump");
                return null;
            }

            var exploit = CreateExploit(exploitType);
            if (exploit == null)
            {
                Log("Failed to create exploit instance");
                return null;
            }

            return await exploit.DumpPreloaderAsync();
        }

        /// <summary>
        /// 禁用安全限制
        /// </summary>
        public bool DisableSecurity()
        {
            if (_currentExploit == null)
            {
                var exploitType = GetRecommendedExploit();
                if (exploitType == ExploitType.None)
                {
                    Log("No exploit available");
                    return false;
                }
                CreateExploit(exploitType);
            }

            return _currentExploit?.DisableRangeBlacklist() ?? false;
        }

        /// <summary>
        /// 崩溃设备进入 BROM
        /// </summary>
        public bool CrashToBrom(int mode = 0)
        {
            if (_currentExploit == null)
            {
                var exploitType = GetRecommendedExploit();
                if (exploitType == ExploitType.None)
                {
                    Log("No exploit available");
                    return false;
                }
                CreateExploit(exploitType);
            }

            return _currentExploit?.CrashDevice(mode) ?? false;
        }

        /// <summary>
        /// 加载并运行 Payload 文件
        /// </summary>
        public async Task<bool> LoadAndRunPayloadAsync(string payloadPath, uint? address = null)
        {
            if (!File.Exists(payloadPath))
            {
                Log($"Payload file not found: {payloadPath}");
                return false;
            }

            byte[] payload = File.ReadAllBytes(payloadPath);
            Log($"Loaded payload: {payloadPath} ({payload.Length} bytes)");

            return await RunPayloadAsync(payload, address);
        }

        /// <summary>
        /// 使用通用 Dump Payload
        /// </summary>
        public async Task<byte[]?> UseDumpPayloadAsync(string payloadDir)
        {
            string dumpPayloadPath = Path.Combine(payloadDir, "generic_dump_payload.bin");

            if (!File.Exists(dumpPayloadPath))
            {
                Log($"Dump payload not found: {dumpPayloadPath}");
                return null;
            }

            byte[] payload = File.ReadAllBytes(dumpPayloadPath);
            Log($"Loaded dump payload: {payload.Length} bytes");

            uint payloadAddr = _chipConfig.BromPayloadAddr;
            if (payloadAddr == 0)
            {
                payloadAddr = 0x100A00; // 默认地址
            }

            if (await RunPayloadAsync(payload, payloadAddr))
            {
                // Dump Payload 会将 BROM 通过 USB 发送回来
                return await DumpBromAsync();
            }

            return null;
        }

        private void Log(string message)
        {
            OnLog?.Invoke($"[ExploitMgr] {message}");
            System.Diagnostics.Debug.WriteLine($"[ExploitMgr] {message}");
        }

        /// <summary>
        /// 清理资源
        /// </summary>
        public void Dispose()
        {
            _currentExploit?.Dispose();
            _currentExploit = null;
        }
    }
}
